
    // checkForVerticalCollisions() {
    //     this.world.level.platforms.forEach(platform => {
    //         if (this.isColliding(platform)) {
    //             if (this.speedY < 0) {
    //                 this.speedY = 0;
    //                 this.y = platform.y - this.height - this.offset.bottom - 0.01;
    //                 this.isAbovePlatform = true;
    //             }
    //             if (this.speedY > 0) {
    //                 this.speedY = 0;
    //                 this.y = platform.y + platform.height + 0.01;
    //                 this.isAbovePlatform = true;

    //             }
    //         }
    //     });
    // }

    // checkForHorizontalCollisions() {
    //     this.world.level.platforms.forEach(platform => {
    //         if (this.isColliding(platform)) {
    //             if (this.speedX < 0) {
    //                 this.speedX = 0;
    //                 !this.isAboveGround();
    //                 this.x = platform.x - this.width - this.offset.right - 0.01;
    //             }
    //             if (this.speedX > 0) {
    //                 this.speedX = 0;
    //                 !this.isAboveGround();
    //                 this.x = platform.x + platform.width + 0.01;
    //             }
    //         }
    //     });
    // }



    
    // checkPlatformsCollision() {
    //     for (const platform of this.world.level.platforms) {
    //         if (this.platformCollision(platform)) {
    //             if (this.speedY < 0 && !this.isOnPlatform) {
    //                 this.speedY = 0;
    //                 this.isOnPlatform = true;
    //                 console.log('onPlatform status', this.isOnPlatform)
    //                 this.y = ((platform.y + platform.offset.top) - (this.height - this.offset.bottom)) - 0.01;
    //                 break
    //             }
    //         }
    //     }
    // }


       // comesFromTop(obj) {
    //     if (
    //         this.speedY < 0 &&
    //         this.isColliding(obj)
    //         // this.isColliding(obj, obj instanceof Snake  || obj instanceof Spider)
    //     ) {
    //         console.log('comeFromTop of', obj instanceof Snake, obj)
    //         return true;
    //     } else if(
    //         this.speedY < 0 &&
    //         this.isAbovePlatform(obj)){
    //         // this.isAbovePlatform(obj, obj instanceof Platforms)){
    //         return true;
    //     }else {
    //         return false;
    //     }
    // }



    // comesFromTop(obj) {
    //     const thisBottom = this.y + this.height - this.offset.bottom;                // trying to improve function to stay on platform
    //     const ObjectTop = obj.y + obj.offset.top;
    //     if (
    //         this.isColliding(obj) &&
    //         this.isAboveGround() &&
    //         this.speedY < 0 &&
    //         thisBottom >= ObjectTop
    //     ) {
    //         return true;
    //     } else {
    //         return false;
    //     }
    // }


    // isOnPlatformTop(obj) {
    //     return (this.x + this.width - this.offset.right) >= obj.x + obj.offset.left &&
    //         (this.x + this.offset.left) >= (obj.x + obj.width - obj.offset.right)
    // }

    // collideFromSide(mo) {
    //     return (mo.x + mo.offset.left, mo.y + mo.offset.top, mo.width - (mo.offset.right + mo.offset.left), mo.height - (mo.offset.top + mo.offset.bottom))
    // }

    // collideFromSide(obj) {
    //     return this.y + this.offset.top <= (obj.y + obj.height - obj.offset.bottom) &&
    //         (this.x + this.offset.left) <= (obj.x + obj.width - obj.offset.right) &&
    //         (this.x + this.width - this.offset.right >= obj.x) ||
    //         (this.x + this.offset.left) <= obj.x
    // }


    
    // collides(obj) {
    //     return (this.x + this.width - this.offset.right) >= obj.x + obj.offset.left ||
    //         (this.x + this.offset.left) <= (obj.x + obj.width - obj.offset.right) // change to right because seems to be logical , change to bottom if problems
    //     // && obj.onCollisionCourse; // Optional: hiermit könnten wir schauen, ob ein Objekt sich in die richtige Richtung bewegt. Nur dann kollidieren wir. Nützlich bei Gegenständen, auf denen man stehen kann.
    // }


    
    // trying to improve function to stay on platform

    // checkPlatformsCollision() {
    //     this.level.platforms.forEach(platform => {
    //         // if(!this.character.isColliding(platform)){
    //         //     this.character.obstacle = false;            // need help to resolve this, obstacle switch between true and false because of isColliding. 
    //         // }

    //         if (this.character.comesFromTop(platform)) {
    //             this.character.isOnPlatform = true;
    //             this.character.y = platform.y + platform.offset.top - this.character.height + this.character.offset.bottom;
    //         }
    //         // if (this.character.isColliding(platform) && !this.character.isOnPlatformTop(platform)) {
    //         //     this.character.isOnPlatform = true;
    //         // }
    //         // if(this.character.collideFromSide(platform)){
    //         //     console.log('coliding')
    //         //     this.character.obstacle = true;             // need help to resolve this, obstacle switch between true and false because of isColliding. 
    //         // }
    //         if (this.character.isOnPlatformTop(platform)) {
    //             this.character.isOnPlatform = false;
    //         }
    //     });
    // }


    function checkPlatformsCollision() {
        this.world.level.platforms.forEach(platform => {
            if(this.comesFromTop(platform)){
            // if(this.comesFromTop(platform) || this.isAbovePlatform(platform)){
                console.log('comefromtopofplatform', this.comesFromTop(platform), 'or isAbovePlatform', this.isAbovePlatform(platform))
                this.landOnPlatform(platform)
            }
            // else if(!this.isAbovePlatform(platform)){
            //     this.isOnPlatform = false;
            // }
        });
    }

    function isAbovePlatform(platform) {
        return this.y + this.height - this.offset.bottom <= platform.y + platform.offset.top
            && (this.x + this.width - this.offset.right) >= (platform.x + platform.offset.left) &&
            (this.x + this.width - this.offset.right) <= (platform.x + platform.width - platform.offset.right) ||
            this.x + this.offsetleft > platform.x + platform.offset.left &&
            this.x + width - this.offset.right < platform.x + platform.width - platform.offset
    }

    function landOnPlatform(platform) {
        console.log('character is on a platform')
        this.isOnPlatform = true;
        this.y = platform.y + platform.offset.top - this.height + this.offset.bottom;
    }




    // function to land on ground or platform before implementing method to climb down

     // tryToLandOn(object) {
    //     if (this.isAboveGroundOf(object)) {
    //         if (this.speedY > 0) {
    //             this.y = ((object.y + object.offset.top) - (this.height - this.offset.bottom));
    //             this.speedY = 0;
    //             this.hasAlreadyJumped = false;
    //         }
    //         if (object instanceof Platforms) this.isOnPlatform = true;
    //         else this.isOnPlatform = false;
    //         if (object instanceof Ground) this.isOnTheGround = true;
    //         if (this.isClimbing) {
    //             if (this.isOnPlatform || this.isOnTheGround) this.isClimbing = false;
    //         }
    //     }
    // }


    // hit() {
    //     if (this instanceof Snake) this.life -= 2;              // 2
    //     if (this instanceof Ent) this.life -= 5;                // 5
    //     if (this instanceof Bear) this.life -= 5;               // 5
    //     if (this instanceof Spider) this.life -= 10;                // 10
    //     if (this instanceof Endboss) this.life -= 0;                // 0
    //     if (this.life < 0) this.life = 0;           
    //     else this.lastHit = new Date().getTime();               
    // }


    // attack(){
    //     if (this instanceof Snake) this.world.character.life -= 1.5;
    //     if (this instanceof Ent) this.world.character.life -= 5;
    //     if (this instanceof Bear) this.world.character.life -= 6;
    //     if (this instanceof Spider) this.world.character.life -= 4;
    //     if (this instanceof Endboss) this.world.character.life -= 0;
    //     if (this.world.character.life < 0) this.world.character.life = 0;
    //     else this.world.character.lastHit = new Date().getTime();
    // }


    
    // applyGravity() {
    //     setInterval(() => {
    //         if(this.speedY < 0){
    //             this.y += this.speedY;
    //             this.speedY += this.gravityAcceleration;
    //         }else {
    //             this.speedY = 0;
    //         }
    //     }, 1000 / 60);
    // }


    // applyGravity() {
    //     setInterval(() => {
    //         if (this.isAboveGround() && !this.isClimbing && !this.isOnPlatform || this.speedY > 0) {
    //             console.log('applyGravity true')
    //             console.log('is on platform', this.isOnPlatform)
    //             this.y -= this.speedY;
    //             this.speedY -= this.gravityAcceleration;
    //         } else {
    //             console.log('applyGravity false')
    //             this.speedY = 0;
    //         }
    //     }, 1000 / 60);
    // }

    // isAboveGround() {
    //     if (this instanceof ThrowableObjects) {
    //         return true;
    //     } else if (!this.isOnPlatform && !this.isDead()) {
    //         return this.y <= this.ground;
    //     } else{
    //         return false;
    //     }
    // }
